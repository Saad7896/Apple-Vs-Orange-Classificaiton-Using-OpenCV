# -*- coding: utf-8 -*-
"""Apple Vs Orange Classification Model.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1m0gtOkh2ccTaqtyZq5r41AtTDhnQgJin
"""

# !ls
#
# !rm -rf */

import tensorflow as tf
import os.path
import pathlib
from pathlib import Path
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from sklearn.model_selection import train_test_split
import seaborn as sns
from sklearn.metrics import confusion_matrix, classification_report
from tensorflow.keras.preprocessing.image import ImageDataGenerator

from google.colab import drive
drive.mount('/content/drive')

image_dir=Path('')
image_path=pathlib.Path(image_dir)

filepaths=list(image_path.glob('*/*.jpg'))
filepaths
labels=list(map(lambda x:os.path.split(os.path.split(x)[0])[1], filepaths))

filepaths=pd.Series(filepaths, name='Filepath').astype(str)
labels=pd.Series(labels, name='Label')
image_df=pd.concat([filepaths,labels], axis=1)
image_df

labels

train_df, test_df=train_test_split(image_df, train_size=0.7, shuffle=True, random_state=1)

"""Load Image Data"""

train_generator=tf.keras.preprocessing.image.ImageDataGenerator(
    rescale=1./255,
    width_shift_range=0.2,
    height_shift_range=0.2,
    validation_split=0.2,
    horizontal_flip=True,
    vertical_flip=True,
    rotation_range=40
)

test_generator=tf.keras.preprocessing.image.ImageDataGenerator(
    rescale=1./255,
)

# Convert the 'Filepath' column to strings
train_df['Filepath'] = train_df['Filepath'].astype(str)

train_images=train_generator.flow_from_dataframe(
    dataframe=train_df,
    x_col='Filepath',
    y_col='Label',
    target_size=(224,224),
    shuffle=True,
    class_mode='binary',
    color_mode='rgb',
    batch_size=32,
    seed=42,
    subset='training'
    )

val_images=train_generator.flow_from_dataframe(
    dataframe=train_df,
    x_col='Filepath',
    y_col='Label',
    target_size=(224,224),
    shuffle=True,
    class_mode='binary',
    color_mode='rgb',
    batch_size=32,
    seed=42,
    subset='validation'
    )
test_images=test_generator.flow_from_dataframe(
    dataframe=train_df,
    x_col='Filepath',
    y_col='Label',
    target_size=(224,224),
    shuffle=False,
    class_mode='binary',
    color_mode='rgb',
    batch_size=32
    )

"""***Training***"""

inputs=tf.keras.Input(shape=(224,224,3))
x=tf.keras.layers.Conv2D(filters=16,kernel_size=(3,3), activation="relu")(inputs)
x=tf.keras.layers.MaxPool2D()(x)
x=tf.keras.layers.Conv2D(filters=32,kernel_size=(3,3), activation="relu")(x)
x=tf.keras.layers.MaxPool2D()(x)
x=tf.keras.layers.GlobalAveragePooling2D()(x)
x=tf.keras.layers.Dense(128, activation="relu")(x)
x=tf.keras.layers.Dense(128, activation="relu")(x)
outputs=tf.keras.layers.Dense(1, activation="sigmoid")(x)

model=tf.keras.Model(inputs=inputs, outputs=outputs)

model.compile(
    optimizer="Adam",
    loss='binary_crossentropy',
    metrics=["accuracy"]
)

history=model.fit(
    train_images,
    validation_data=val_images,
    epochs=100,
    callbacks=[
        tf.keras.callbacks.EarlyStopping(
            monitor='val_loss',
            patience=5,
            restore_best_weights=True
        ),
        tf.keras.callbacks.ReduceLROnPlateau(
            monitor='val_loss',
            patience=3,
            resotore_best_weights=True
        )
    ]

)

results=model.evaluate(test_images, verbose=0)
print("Test Loss: {:.5f}".format(results[0]))
print("Test Accuracy: {:.2f}%".format(results[1]*100))

predictions=(model.predict(test_images)>0.5).astype(int)

cm=confusion_matrix(test_images.labels, predictions, labels=[0,1])

clr=classification_report(test_images.labels, predictions, labels=[0,1], target_names=["Apple", "Orange"])


plt.figure(figsize=(6,6))
sns.heatmap(cm, annot=True, fmt='g',cbar='Blues', vmin=0,)
plt.xticks([0.5, 1.5], labels=["Apple", "Orange"])
plt.yticks([0.5, 1.5], labels=["Apple", "Orange"])
plt.xlabel("Predictions")
plt.ylabel("Actual")
plt.title("Confusion Matrix")
plt.show()

print("Classification Report: \n-/n", clr)

x.shape

train_images.class_indices